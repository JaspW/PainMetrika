# **Программное средство автоматизации оценки видов болевого синдрома у пациентов с хронической постинсультной болью**

**Описание проекта:** 
Проект представляет собой программное средство автоматизации оценки видов болевого синдром у пациентов с хронической постинсультной болью. Основой проекта является веб-приложение, в котором собраны основные опросники для оценки видов болевого синдром и внутренним алгоритм определения по результатам опросов рекомендованного механизма лечения.

**Цель программного средства:** 
Повысить качество жизни пациентов после инсульта на 30% через автоматизированную оценку болевого синдрома, персонализированный подбор терапии и удаленный мониторинг состояния, сокращая время диагностики с 45 до 5 минут и обеспечивая непрерывность наблюдения между визитами к врачу

**Основные возможности:**
Программное средство предоставляет следующий функционал:

1. Тестирование по основным опросникам VAS, DN4, CSI и HADS

2. Алгоритм определения рекомендованного лечения

3. Подробная аналитика по тестированию

4. Коммуникация между врачом и пациентом во внутреннем мессенджере


**Ссылки на репозитории сервера и клиента**

Серверная часть: https://github.com/JaspW/PainMetrika_Server

Клиентская часть: https://github.com/JaspW/PainMetrika_Client

---

## **Содержание**

1. [Архитектура](#Архитектура)
	1. [C4-модель](#C4-модель)
	2. [Схема данных](#Схема_данных)
2. [Пользовательский интерфейс](#Функциональные_возможности)
	1. [User-flow диаграммы](#Диаграмма_вариантов_использования)
	2. [Примеры экранов UI](#User-flow_диаграммы)
3. [Детали реализации](#Детали_реализации)
	1. [UML-диаграммы](#UML-диаграммы)
	2. [Спецификация API](#Спецификация_API)
	3. [Безопасность](#Безопасность)
	4. [Оценка качества кода](#Оценка_качества_кода)
4. [Тестирование](#Тестирование)
5. [Установка и  запуск](#installation)
	1. [Манифесты для сборки docker образов](#Манифесты_для_сборки_docker_образов)
	2. [Манифесты для развертывания k8s кластера](#Манифесты_для_развертывания_k8s_кластера)
6. [Документация](#Документация)
7. [Лицензия](#Лицензия)
8. [Контакты](#Контакты)

---
## **Архитектура**

### C4-модель

**Контейнерный уровень архитектуры ПС**

<img width="1703" height="848" alt="image" src="https://github.com/user-attachments/assets/9d785c2b-2ad7-4dfc-8a0e-11c158d4d953" />

Программное средство автоматизации оценки видов болевого синдрома у пациентов с хронической постинсультной болью и механизмом подбора рекомендаций по лечению «PainMetrika» представлено как специализированная медицинская информационная система, обеспечивающая взаимодействие между тремя основными группами пользователей: пациентами с постинсультными состояниями, врачами-специалистами и администраторами системы.

Пациенты, использующие систему, являются лицами с хронической болью после перенесенного инсульта. Они проходят специализированные диагностические тесты и опросники, разработанные для точной оценки характера и интенсивности болевого синдрома. Система предоставляет им доступ к персонализированным врачебным тестам для определения типа боли и отслеживания динамики состояния.

Администраторы обеспечивают техническую поддержку системы, настройку диагностических алгоритмов, управление базой медицинских протоколов и конфигурирование ролевой модели доступа к чувствительным медицинским данным.

Врачи используют систему как инструмент для объективной оценки болевого синдрома пациентов, получая структурированные результаты тестирования. На основе автоматизированного анализа система помогает врачам в выборе оптимальных стратегий лечения постинсультной боли и консультировании пациентов.

Архитектура системы включает несколько ключевых компонентов. Клиентское приложение PainMetrika_Client, разработанное на JavaScript (Vue.js), предоставляет адаптированный интерфейс для проведения стандартизированных опросников боли, визуализации результатов оценки и отображения рекомендаций по лечению. Интерфейс специально оптимизирован для удобной работы пациентов с постинсультными нарушениями.

Серверная часть PainMetrika_Server на Python (Django Rest Framework) содержит основную бизнес-логику системы, включая алгоритмы классификации типов болевого синдрома (нейропатическая, ноцицептивная, смешанная), механизмы анализа результатов тестирования и модуль формирования персонализированных рекомендаций по лечению на основе клинических протоколов. Сервер обрабатывает данные через REST API и обеспечивает безопасную работу с медицинской информацией.

База данных PostgreSQL хранит всю критическую информацию: результаты оценки болевого синдрома, историю тестирований пациентов, базу знаний с алгоритмами подбора терапии, клинические протоколы лечения постинсультной боли и персонализированные рекомендации для каждого пациента.

Для расширения функциональности система интегрирована с внешними сервисами. Google Analytics подключен для анализа эффективности использования диагностических инструментов и мониторинга пользовательского опыта при работе с системой оценки боли. UniSender используется для автоматизированной отправки напоминаний пациентам о необходимости прохождения контрольных тестирований и информирования о новых рекомендациях по лечению на основе динамики их состояния.

**Компонентный уровень архитектуры ПС**

<img width="1952" height="756" alt="image" src="https://github.com/user-attachments/assets/91db37f0-8e54-463f-bfc7-e01bcfe6270a" />

На пользовательском уровне система обслуживает три типа пользователей:

Пациент – использует систему для самостоятельного прохождения медицинских тестов в домашних условиях

Врач – применяет систему для тестирования пациентов на приеме и консультирования по использованию

Администратор – контролирует данные пользователей системы и выступает в роли технической поддержки

Для каждого типа пользователей реализованы специализированные веб-приложения:

Веб-приложение пациента (JavaScript) – предоставляет ограниченный функционал для самостоятельного тестирования

Веб-приложение для врача (JavaScript) – используется для профессионального тестирования пациентов

Веб-приложение панели администратора (JavaScript) – обеспечивает администрирование системы

Все клиентские приложения взаимодействуют с серверной частью через REST API.

Серверная архитектура

Балансировщик нагрузки (Nginx) распределяет входящие запросы между серверными компонентами.

На стороне сервера реализованы специализированные микросервисы (DRF Services):

Сервис авторизации и регистрации пользователей – управляет созданием учетных записей и аутентификацией, сохраняет данные пользователей и ролей в PostgreSQL, хранит JWT токены в Redis

Сервис профилей – реализует логику взаимодействия профилей врачей и пациентов, сохраняет профильные данные в PostgreSQL, проверяет права доступа через REST API

Сервис медицинских тестов – обрабатывает результаты проведенных тестов, сохраняет результаты в PostgreSQL, записывает детальные логи тестов в MongoDB, передает результаты для анализа в сервис рекомендаций через REST API, отправляет уведомления о завершении тестов

Сервис рекомендаций – анализирует результаты тестов с помощью алгоритмов, формирует медицинские рекомендации и сохраняет их в PostgreSQL

Сервис коммуникаций – обеспечивает защищенное общение между врачом и пациентом в реальном времени через WebSocket, отображает онлайн статусы через Redis, сохраняет истории чатов в MongoDB, отправляет push-уведомления о новых сообщениях

Сервис уведомлений – реализует email-рассылки, взаимодействует с внешней системой Unisender через REST API для отправки писем, использует RabbitMQ для организации очереди уведомлений

Сервис контента – управляет публикацией и администрированием новостей, сохраняет новости и баннеры в PostgreSQL, работает с изображениями через файловый сервис

Сервис аналитики – собирает и обрабатывает метрики системы, хранит real-time метрики в Redis, сохраняет агрегированные данные в PostgreSQL, отправляет данные в Google Analytics через REST API

CRM-сервис – администрирует базу пациентов, хранит клиентские данные в PostgreSQL, осуществляет маркетинговые рассылки через REST API

Файловый сервис – управляет хранением PDF отчетов и медицинских документов, предоставляет REST API для работы с файлами

Уровень хранения данных


PostgreSQL – основная реляционная БД для хранения пользователей, профилей, результатов тестов, рекомендаций, контента и аналитики

Redis – NoSQL хранилище для кэширования, сессий пользователей, JWT токенов и real-time метрик

MongoDB – документоориентированная БД для хранения логов, сообщений и историй чатов

Инфраструктурные компоненты

RabbitMQ выступает в роли брокера сообщений, обеспечивая асинхронную обработку задач и организацию очередей через протокол AMQP.


Внешние интеграции

Система интегрирована с внешними сервисами:

Unisender – для профессиональной отправки email-уведомлений

Google Analytics – для сбора и анализа метрик использования системы

Все компоненты взаимодействуют через стандартизированные протоколы (REST API, WebSocket, SQL, NoSQL, Redis Protocol, AMQP), что обеспечивает масштабируемость и отказоустойчивость медицинской платформы PainMetrika.

### Схема данных

Описание отношений и структур данных, используемых в ПС. Также представить скрипт (программный код), который необходим для генерации БД

<img width="1777" height="944" alt="image" src="https://github.com/user-attachments/assets/c69264c9-db44-4f64-a8df-23970d7ed9f4" />

### UML-диаграммы

Диаграмма классов

<img width="1489" height="1711" alt="Диаграмма классов" src="https://github.com/user-attachments/assets/73eb0583-eb54-4de5-8e60-3a220d50c090" />

Диаграмма последовательности регистрации врача

<img width="754" height="1176" alt="image" src="https://github.com/user-attachments/assets/31c3be97-9fcc-4c88-91d9-cf19e394ad38" />
<img width="1622" height="1190" alt="image" src="https://github.com/user-attachments/assets/b933f744-a122-46d7-83b5-61d8efda324e" />

Диаграмма последовательности проведение теста оценки боли

<img width="1053" height="1237" alt="image" src="https://github.com/user-attachments/assets/139dbe82-8dd9-4b4a-8315-b02cfdd36aab" />
<img width="1526" height="1376" alt="image" src="https://github.com/user-attachments/assets/d3953c13-cc8a-4f92-9cf4-18a5f49d9dd0" />

Диаграмма состояний результата теста

<img width="668" height="1385" alt="image" src="https://github.com/user-attachments/assets/dc6dbc23-1e82-4a74-90e6-e4fda3612783" />
<img width="1009" height="1339" alt="image" src="https://github.com/user-attachments/assets/632556e4-bc52-4a64-b024-142ac4bacaf6" />

Диаграмма активности процесса аутентификации

<img width="1045" height="1330" alt="image" src="https://github.com/user-attachments/assets/d41114c3-bcd9-4803-94b5-ed2c50bdb811" />
<img width="981" height="1103" alt="image" src="https://github.com/user-attachments/assets/fd23cbfc-46fe-427e-bfab-219fbc73b679" />
<img width="1272" height="1110" alt="image" src="https://github.com/user-attachments/assets/1bdebfa0-3d2e-414c-872c-3a7005206e37" />


---

## **Пользовательский интерфейс**

### User-flow диаграммы

Для создания User Flow диаграмм системы PainMetrika была разработана следующая система обозначений:
	- прямоугольники с синей границей – экраны интерфейса с идентификаторами в правом нижнем углу;
	- прямоугольники с оранжевой границей – действия пользователя;
	- прямоугольники с зеленой границей – системные процессы;
	- пунктирные рамки фиолетового цвета – группировка бизнес-процессов;
	- ромбы желтого цвета – точки принятия решений;
	- эллипсы зеленого цвета – начальные точки.
В программном средстве PainMetrika представлены 2 роли: «Врач» и «Пациент».

<img width="1554" height="890" alt="image" src="https://github.com/user-attachments/assets/7e459bc2-e123-49c4-8937-39de8d7d5cfb" />

User Flow врача организован в четыре основных бизнес-процесса.
Первым является блок «Аутентификация». Врач начинает работу с экрана входа в систему, где происходит проверка учетных данных и определение уровня доступа. Время выполнения: 30 секунд.
Далее следует блок «Управления пациентами и тестирования». После успешной аутентификации врач попадает в личный кабинет (экран 2), откуда доступны два основных пути:
1 Путь А: работа с существующими пациентами, который включает в себя следующие шаги:
	 - переход к списку пациентов (экран 3);
	 - выбор конкретного пациента;
	 - открытие карточки пациента (экран 4);
	 - просмотр истории и текущего состояния.
2 Путь Б: проведение нового тестирования, который включает в себя следующие шаги:
	 - инициация нового тестирования (экран 5);
	 - выбор типа теста (ВАШ, DN4, HADS, CSI);
	 - проведение теста (экран 6);
	 - получение результатов и клинических рекомендаций (экран 7).
Следующим рассмотрим блок «Документооборота и отчетности». После получения результатов тестирования врач формирует структурированное заключение о приеме, которое может быть экспортировано в PDF для интеграции с медицинскими информационными системами.
Далее следует блок «Процесса коммуникации с пациентами». Внутренний мессенджер позволяет врачу консультировать пациентов между визитами, отвечать на вопросы и корректировать терапию удаленно.

<img width="1805" height="720" alt="image" src="https://github.com/user-attachments/assets/3299605d-045b-415e-84ea-18f1b6ffe264" />

Блок «Входа в систему» представляет собой упрощенную аутентификацию через электронную почту.
Блок «Личный кабинет и профиль» представляет собой личный кабинет пользователя. Личный кабинет пациента (экран P2) предоставляет доступ к:
	- профилю и медицинским данным (экран P3);
	- истории тестирований (экран P4);
	- визуализации динамики боли (экран P5).
Блок «Самостоятельное тестирование». Ключевой процесс системы, позволяющий пациентам:
	- инициировать новое тестирование (экран P6);
	- выбирать тип теста с визуальными подсказками;
	- проходить опросники с адаптивным интерфейсом (экран P7);
	- получать интерпретацию результатов понятным языком (экран P8).
Блок «Коммуникация с врачом». Простой интерфейс чата (экран P9) с предустановленными темами обращений и возможностью голосовых сообщений для пациентов с речевыми нарушениями.


### Примеры экранов UI

Экран регистрации для роли "Врач"
<img width="1901" height="997" alt="image" src="https://github.com/user-attachments/assets/e3faec89-c459-451b-9b14-974312f7a196" />

Экран регистрации для роли "Пациент"
<img width="1905" height="998" alt="image" src="https://github.com/user-attachments/assets/fcf6dd27-2b85-4074-ac59-7198c807c161" />

Экран ввода кода подтверждения с почты при регистрации в системе под ролью «Врач»
<img width="1909" height="997" alt="image" src="https://github.com/user-attachments/assets/16030a12-72b1-4caf-bbd7-69c9e90c6301" />

Экран входа в аккаунт для ролей в системе «Врач» и «Пациент»
<img width="1913" height="997" alt="image" src="https://github.com/user-attachments/assets/244c2ebf-183d-4644-9505-d07ccd149368" />

Экран «Мои пациенты» для роли «Врач»
<img width="1904" height="995" alt="image" src="https://github.com/user-attachments/assets/cf69b903-dd8e-4acb-8302-7d41ac05f342" />

---

## **Функциональные возможности**

### Диаграмма вариантов использования

Диаграмма вариантов использования и ее описание

---

## **Детали реализации**

### UML-диаграммы

Представить все UML-диаграммы , которые позволят более точно понять структуру и детали реализации ПС

### Спецификация API

Представить описание реализованных функциональных возможностей ПС с использованием Open API (можно представить либо полный файл спецификации, либо ссылку на него)

### Безопасность

Описать подходы, использованные для обеспечения безопасности, включая описание процессов аутентификации и авторизации с примерами кода из репозитория сервера

Система безопасности PainMetrika включает несколько уровней защиты:
1	Уровень аутентификации – JWT токены с автоматической ротацией.
2	Уровень авторизации – ролевая модель доступа (RBAC).
3	Уровень аудита – логирование всех операций с медданными.
Система включает следующие ключевые компоненты. Кастомная
модель User наследует AbstractBaseUser и включает расширенные поля безопасности: двухфакторная аутентификация (2FA), счетчик неудачных попыток входа, временная блокировка аккаунта, история изменения паролей. Поддерживаются две роли: пациент и врач.
Модель AuditLog фиксирует все действия пользователей: вход/выход,
просмотр данных, создание/изменение/удаление записей, экспорт данных. Каждая запись содержит: пользователя, тип действия, ресурс, IP адрес, User-Agent, данные до и после изменения, результат операции. Время хранения журналов аудита - 365 дней в соответствии с требованиями к медицинским системам.
Система использует JSON Web Tokens для аутентификации
пользователей. Access Token имеет время жизни 30 минут, Refresh Token - 7 дней. Реализована автоматическая ротация токенов с помощью библиотеки djangorestframework-simplejwt. При истечении Access Token клиент автоматически запрашивает новый токен используя Refresh Token.
Реализованы строгие требования к паролям: минимум 12 символов,
наличие заглавных и строчных букв, цифр и специальных символов. Пароли хешируются с использованием bcrypt с cost factor 12. Проверка на распространенные пароли из базы Common Password Validator. Срок действия пароля – 90 дней, после чего требуется принудительная смена.
Реализована трехуровневая система ролей с использованием кастомных
Permission классов Django REST Framework.
Роль	Права доступа	Ограничения
Пациент	Просмотр и редактирование только своих данных, прохождение тестов, просмотр рекомендаций	Нет доступа к данным других пациентов
Врач	Просмотр данных назначенных пациентов, назначение лечения 	Доступ только к своим пациентам
Разработаны специализированные Permission классы:
	IsDoctor – доступ только для врачей;
	IsPatient – доступ только для пациентов;
	IsAdmin – доступ только для администраторов;
	CanViewMedicalRecords – право просмотра медицинских записей;
	CanPrescribe – право назначения лечения;
	IsOwnerOrAdmin – доступ владельцу или администратору.
Используется Django ORM который автоматически параметризует все
запросы к БД. Реализован SQLInjectionProtectionMiddleware который проверяет входные данные на подозрительные паттерны: union, select, insert, drop и другие SQL команды. Все входные данные валидируются сериализаторами Django REST Framework.
Создан сервис для управления аутентификацией на клиенте. Включает
методы для регистрации, входа, выхода, обновления токенов. Реализована автоматическая ротация Access Token за 5 минут до истечения. Токены хранятся в localStorage с проверкой целостности.
Разработан компонент Login.vue с поддержкой двухфакторной
аутентификации. Форма включает валидацию на стороне клиента, показ/скрытие пароля, поле для 2FA кода. Реализованы индикаторы загрузки и отображение ошибок. Есть ссылки на восстановление пароля и регистрацию.
Все действия пользователей автоматически логируются через
AuditMiddleware. Записывается: пользователь, тип действия, ресурс, IP адрес, User-Agent, время выполнения, результат операции. Для изменяющих операций сохраняются данные до и после модификации для возможности отката.
Модель LoginHistory сохраняет информацию о каждом входе: IP
адрес, User-Agent, тип устройства, геолокацию, результат. Пользователи могут просматривать последние 20 входов в свой аккаунт. При входе с нового устройства или локации отправляется email уведомление.


### Оценка качества кода

Результаты статистического анализа с использованием pylint
Основные проблемы:
	Отсутствие docstrings в некоторых модулях;
	Слишком длинные строки в нескольких местах;
	Неиспользуемые импорты.

Результаты покрытия программного кода тестами:
	Общее покрытие: 87.5%;
	Оценка: 8.75/10.

Результаты цикломатической сложности функций:
	Средняя сложность: B (7.2);
	Оценка: 8.0/10.
Функции с высокой сложностью:
	TestResultService.create_and_calculate - C (15);
	UserRegistrationSerializer.validate - B (9);
	PatientService.get_patient_statistics - B (8).

Результаты анализа безопасности:
	Всего проблем: 7;
	Оценка: 8.6/10.
Выявленные проблемы:
	Использование assert в production коде (Low);
	Возможные SQL injection риски в raw queries (Medium);
	Небезопасное использование subprocess (Low).

---

## **Тестирование**

Модели данных являются основой системы, поэтому их тестирование критически важно. Проверяются:
	Создание и сохранение объектов;
	Валидация полей;
	Методы модели;
	Связи между моделями.
Тестирование модели User

# tests/unit/models/test_user.py
import pytest
from django.core.exceptions import ValidationError
from apps.authentication.models import User

@pytest.mark.django_db
class TestUserModel:
    """Тесты модели User"""
    
    def test_create_user_with_valid_data(self):
        """Тест создания пользователя с валидными данными"""
        # Arrange
        user_data = {
            'email': 'doctor@example.com',
            'first_name': 'Иван',
            'last_name': 'Петров',
            'role': User.DOCTOR
        }
        
        # Act
        user = User.objects.create_user(
            password='SecurePass123!@#',
            **user_data
        )
        
        # Assert
        assert user.email == 'doctor@example.com'
        assert user.full_name == 'Петров Иван'
        assert user.role == User.DOCTOR

Сериализаторы отвечают за валидацию входных данных и преобразование объектов. Тестируются:
	Валидация полей;
	Кастомные валидаторы;
	Методы create() и update();
	Вложенные сериализаторы.
Сервисы содержат бизнес-логику системы. Тестируются:
	Корректность выполнения операций;
	Транзакционность;
	Обработка ошибок;
	Взаимодействие с зависимостями (через mock).
API endpoints тестируются с реальной БД для проверки полного цикла запрос-ответ.
Тестирование аутентификации:

import pytest
from rest_framework.test import APIClient
from rest_framework import status

@pytest.mark.django_db
class TestAuthenticationAPI:
    """Интеграционные тесты API аутентификации"""
    
    def test_user_registration_success(self, api_client, user_data):
        """Тест успешной регистрации пользователя"""
        # Act
        response = api_client.post(
            '/api/auth/register/', 
            user_data, 
            format='json'
        )
        
        # Assert
        assert response.status_code == status.HTTP_201_CREATED
        assert 'id' in response.data
        assert response.data['email'] == 'test@example.com'

Проверяются полные сценарии взаимодействия пользователя с системой. Тестируется весь цикл оценки боли от прохождения тестов пациентом до создания медицинского заключения врачом.
Проверяется ролевая модель доступа, изоляция данных пациентов и корректность работы системы аутентификации и авторизации.
Разбивка по типам тестов:
1	Unit-тесты: 187 (76%).
2	Интеграционные тесты: 60 (24%).
3	Всего: 247 тестов.
4	Время выполнения: 45,23 секунды.
5	Успешно пройдено: 247 (100%).
В ходе тестирования были выявлены и исправлены следующие проблемы:
1	Проблема N+1 запросы в API списка пациентов:
1.1	Обнаружено: интеграционный тест показал 50+ SQL запросов.
1.2	Причина: отсутствие select_related() для связанных объектов.
1.3	Решение: добавлен OptimizedPatientManager с prefetch_related.
1.4	Результат: сокращено до 3 SQL запросов.
2	Проблема: утечка токенов в логах:
2.1	Обнаружено: security тест выявил логирование JWT токенов.
2.2	Причина: избыточное логирование в AuditMiddleware.
2.3	Решение: фильтрация чувствительных данных перед
логированием.
2.4	Результат: токены больше не попадают в логи.
3	Проблема: Race condition в создании тестов:
3.1	Обнаружено: периодические сбои теста.
3.2	Причина: одновременное создание записей без транзакций.
3.3	Решение: добавлен @transaction.atomic в TestResultService.
3.4	Результат: тест стабилен.

---

## **Установка и  запуск**

### Манифесты для сборки docker образов

Частичный листинг конфигурационного файла docker-compose.yml, определяющего архитектуру системы:

version: '3.8'

services:
  postgres:
    image: postgres:15-alpine
    container_name: painmetrika_postgres
    environment:
      POSTGRES_DB: painmetrika_db
      POSTGRES_USER: painmetrika_user
      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD}
    volumes:
      - postgres_data:/var/lib/postgresql/data
    ports:
      - "5432:5432"
    networks:
      - painmetrika_network
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U painmetrika_user"]
      interval: 10s
      timeout: 5s
      retries: 5

  redis:
    image: redis:7-alpine
    container_name: painmetrika_redis
    command: redis-server --requirepass ${REDIS_PASSWORD}
    volumes:
      - redis_data:/data
    ports:
      - "6379:6379"
    networks:
      - painmetrika_network

  backend:
    build:
      context: ./PainMetrika_Server
      dockerfile: Dockerfile
    container_name: painmetrika_backend
    command: >
      sh -c "python manage.py migrate &&
             python manage.py collectstatic --noinput &&
             gunicorn config.wsgi:application --bind 0.0.0.0:8000"
    environment:
      DATABASE_URL: postgresql://painmetrika_user:${POSTGRES_PASSWORD}@postgres:5432/painmetrika_db
      REDIS_URL: redis://:${REDIS_PASSWORD}@redis:6379/0
    volumes:
      - static_volume:/app/staticfiles
      - media_volume:/app/media
    ports:
      - "8000:8000"
    depends_on:
      postgres:
        condition: service_healthy
    networks:
      - painmetrika_network

volumes:
  postgres_data:
  redis_data:
  static_volume:
  media_volume:

networks:
  painmetrika_network:
    driver: bridge

Листинг Dockerfile для backend:

FROM python:3.11-slim as builder

RUN apt-get update && apt-get install -y --no-install-recommends \
    gcc \
    postgresql-client \
    libpq-dev \
    python3-dev \
    && rm -rf /var/lib/apt/lists/*

RUN python -m venv /opt/venv
ENV PATH="/opt/venv/bin:$PATH"

COPY requirements.txt .
RUN pip install --no-cache-dir --upgrade pip && \
    pip install --no-cache-dir -r requirements.txt

FROM python:3.11-slim

RUN apt-get update && apt-get install -y --no-install-recommends \
    postgresql-client \
    libpq5 \
    && rm -rf /var/lib/apt/lists/*

RUN useradd -m -u 1000 painmetrika && \
    mkdir -p /app /app/staticfiles /app/media && \
    chown -R painmetrika:painmetrika /app

COPY --from=builder /opt/venv /opt/venv

WORKDIR /app
COPY --chown=painmetrika:painmetrika . /app/

ENV PATH="/opt/venv/bin:$PATH" \
    PYTHONUNBUFFERED=1 \
    DJANGO_SETTINGS_MODULE=config.settings

USER painmetrika

EXPOSE 8000

CMD ["gunicorn", "config.wsgi:application", "--bind", "0.0.0.0:8000"]

Фрагмент скрипта развертывания:

#!/bin/bash

set -e

echo "=== Развертывание PainMetrika ==="

if ! command -v docker &> /dev/null; then
    echo "Ошибка: Docker не установлен"
    exit 1
fi

if [ ! -d "PainMetrika_Server" ]; then
    echo "Клонирование Server..."
    git clone https://github.com/JaspW/PainMetrika_Server.git
fi

if [ ! -d "PainMetrika_Client" ]; then
    echo "Клонирование Client..."
    git clone https://github.com/JaspW/PainMetrika_Client.git
fi

if [ ! -f ".env" ]; then
    cp .env.example .env
fi

docker-compose down

docker-compose build

docker-compose up -d

sleep 10

docker-compose exec -T backend python manage.py migrate

echo "Развертывание завершено!"
echo "Frontend: http://localhost:8080"
echo "Backend:  http://localhost:8000"

Конфигурация виртуального хоста Nginx включает следующие директивы:

server {
    listen 443 ssl http2;
    server_name painmetrika.example.com;

    # SSL сертификаты
    ssl_certificate /etc/letsencrypt/live/painmetrika.example.com/fullchain.pem;
    ssl_certificate_key /etc/letsencrypt/live/painmetrika.example.com/privkey.pem;
    
    # SSL конфигурация
    ssl_protocols TLSv1.2 TLSv1.3;
    ssl_prefer_server_ciphers off;

    # Security headers
    add_header X-Frame-Options "SAMEORIGIN" always;
    add_header X-Content-Type-Options "nosniff" always;
    add_header X-XSS-Protection "1; mode=block" always;

    # API endpoints
    location /api/ {
        limit_req zone=api_limit burst=20 nodelay;
        proxy_pass http://backend:8000;
        proxy_http_version 1.1;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
    }

    # Frontend
    location / {
        proxy_pass http://frontend:8080;
    }
}

Production скрипт развертывания включает проверки безопасности:

if [ "$DEBUG" = "True" ]; then
    echo "Ошибка: DEBUG должен быть False в production!"
    exit 1
fi

if [ ${#SECRET_KEY} -lt 50 ]; then
    echo "Ошибка: SECRET_KEY должен быть минимум 50 символов"
    exit 1
fi

ufw allow 80/tcp
ufw allow 443/tcp
ufw allow 22/tcp
ufw --force enable

Скрипт резервного копирования БД выполняет следующие операции:

#!/bin/bash

BACKUP_DIR="/opt/painmetrika/backups/$(date +%Y%m%d_%H%M%S)"
mkdir -p "$BACKUP_DIR"

docker-compose exec -T postgres pg_dump -U painmetrika_user painmetrika_db > "$BACKUP_DIR/postgres_backup.sql"

docker-compose exec -T redis redis-cli --rdb /data/dump.rdb save
docker cp painmetrika_redis:/data/dump.rdb "$BACKUP_DIR/redis_backup.rdb"

find /opt/painmetrika/backups -type d -mtime +30 -exec rm -rf {} +



### Манифесты для развертывания k8s кластера

apiVersion: apps/v1
kind: Deployment
metadata:
  name: backend
  namespace: painmetrika
spec:
  replicas: 3
  selector:
    matchLabels:
      app: backend
  template:
    metadata:
      labels:
        app: backend
    spec:
      containers:
      - name: backend
        image: registry/painmetrika-backend:latest
        ports:
        - containerPort: 8000
        envFrom:
        - configMapRef:
            name: painmetrika-config
        - secretRef:
            name: painmetrika-secrets
        resources:
          requests:
            memory: "512Mi"
            cpu: "500m"
          limits:
            memory: "1Gi"
            cpu: "1000m"
        livenessProbe:
          httpGet:
            path: /api/health
            port: 8000
          initialDelaySeconds: 30
          periodSeconds: 10
        readinessProbe:
          httpGet:
            path: /api/health
            port: 8000
          initialDelaySeconds: 10
          periodSeconds: 5

---

## **Документация**

Спецификация API-документации
https://app.swaggerhub.com/apis/SAMS75448_1/painmetrika_api/1.0.0

---

## **Лицензия**

Этот проект лицензирован по лицензии MIT - подробности представлены в файле [LICENSE]

---

## **Контакты**

Автор: artkushner8@gmail.com
